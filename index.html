<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Te4MIVal的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Te4MIVal的个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Te4MIVal的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Te4MIVal">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Te4MIVal的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Te4MIVal的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2023.3.23[Turing Complete攻略]" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/23/2023.3.23%5BTuring%20Complete%E6%94%BB%E7%95%A5%5D/" class="article-date">
  <time class="dt-published" datetime="2023-03-23T13:36:27.498Z" itemprop="datePublished">2023-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="title-test-t"><a href="#title-test-t" class="headerlink" title="title:test![t]"></a>title:test![t]</h2><p><img src="/images/t.png" alt="images"></p>
<p><img src="/img/img.png" alt="mg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/23/2023.3.23[Turing%20Complete%E6%94%BB%E7%95%A5]/" data-id="clfl8f6iz0003fou3avpsg0qn" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2023.3.23[STM32硬件]" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/23/2023.3.23%5BSTM32%E7%A1%AC%E4%BB%B6%5D/" class="article-date">
  <time class="dt-published" datetime="2023-03-23T13:13:27.300Z" itemprop="datePublished">2023-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/23/2023.3.23%5BSTM32%E7%A1%AC%E4%BB%B6%5D/">STM32F103ZE部分硬件配置指南</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>板子所采用的是STMF103ZE，仅提供一些常用模块的基础配置介绍，如有错误请联系作者</strong></p>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="软件设置"><a href="#软件设置" class="headerlink" title="软件设置"></a>软件设置</h3><p>DARMSTM.DLL	-p STM32F103ZE</p>
<p>TARMSTM.DLL</p>
<h3 id="C位运算语法基础"><a href="#C位运算语法基础" class="headerlink" title="C位运算语法基础"></a>C位运算语法基础</h3><p>&lt;&lt;(左移一位)	&gt;&gt;(右移一位)	|(按位或)	&amp;(按位与)	优先级都高于&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=1&lt;&lt;2|1&lt;&lt;4			//将(10100赋给A)</span><br><span class="line">A=A|1				//将A的最后一位置1,不影响其他位</span><br><span class="line">A=A&amp;(0xFFFFFFFF-1)	//将A的最后一位置0,不影响其他位</span><br></pre></td></tr></table></figure>



<h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><h3 id="向量表"><a href="#向量表" class="headerlink" title="向量表"></a>向量表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*汇编程序的向量表片段*/</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler	;声明其为全局变量,使得程序外也可调用</span><br><span class="line">		</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __intitial_sp</span><br><span class="line">	DCD Reset_Handler	;复位向量表,为向量表中的第一项,程序从这里进入</span><br><span class="line">	......</span><br><span class="line">	DCD </span><br><span class="line">	</span><br><span class="line">Reset_Handler PROC</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	ENDP</span><br></pre></td></tr></table></figure>

<p>中断是在CPU执行过程中,产生了预先设置的中断触发,从而停止当前进程运行中断子进程,最后回到原位置</p>
<table>
<thead>
<tr>
<th align="center">向量号</th>
<th align="center">类型</th>
<th align="center">优先级</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">无异常处理</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">Reset</td>
<td align="center">-3</td>
<td align="center">复位</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">NMI</td>
<td align="center">-2</td>
<td align="center">不可屏蔽中断(来自NMI管脚)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">HardFault</td>
<td align="center">-1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SysTick</td>
<td align="center">可编程</td>
<td align="center">系统TICK定时器超时</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">IRQ0</td>
<td align="center">可编程</td>
<td align="center">外部设备产生的中断</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">255</td>
<td align="center">IRQ239</td>
<td align="center">可编程</td>
<td align="center">外部设备产生的中断</td>
</tr>
</tbody></table>
<p>总共有15种系统中断,有240种外部中断,外部中断由**NVIC(中断控制器)**统一管理</p>
<p>**优先级:**优先级数越小,优先级最高,因为复位为最高优先级,因此为最高的-3,可编程优先级不可为负数</p>
<p>向量表的每个向量占据4个字节,从0x00000000开始</p>
<p>每个向量的地址固定,声明的时候如果使用的向量前面的向量未全部列举,则需要用SPACE N*4填充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*示例:调用向量号为11的SVCall内部中断*/</span><br><span class="line">__Vectors</span><br><span class="line">	DCD _initial_sp</span><br><span class="line">	DCD RESET_Handler</span><br><span class="line">	SPACE 9*4			;向量号为11,前面有10个向量,已经列举了RESET,因此还有9个需要填充</span><br><span class="line">	DCD SVC_Handler</span><br><span class="line">	</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">Reset_Handler PROC</span><br><span class="line">	...</span><br><span class="line">	ENDP</span><br><span class="line">	</span><br><span class="line">SVC_Handler	PROC</span><br><span class="line">	...</span><br><span class="line">	ENDP</span><br></pre></td></tr></table></figure>

<p>外部中断类似,需要注意的是 <strong>外部向量中断号+16&#x3D;向量号</strong>(内部中断从1开始计数,外部中断从0开始)</p>
<p>向量表中的每一个向量存放的都是异常入口的起始地址,而每个向量自己的地址为0x08000000+4*向量号</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>当产生异常时,CPU根据异常向量号,跳转到该异常处理程序所在的位置开始执行,且保护此之前的数据便于之后跳回</p>
<p>(将R0-R3、R12、LR、PC、xPSR依次压入栈)<strong>而其他寄存器需要手动入栈！</strong>并在异常执行完之前取回</p>
<p>在进入异常子过程后,LR实际上不会直接指向上一个进程的位置,而是变成一个状态字(0xFFFFFFFX:EXIT_RETURN),告诉程序在异常子过程结尾的BX LR处释放出刚刚入栈的几个数据,再根据数据返回并继续程序</p>
<h3 id="SETENAx（使能与除能寄存器）"><a href="#SETENAx（使能与除能寄存器）" class="headerlink" title="SETENAx（使能与除能寄存器）"></a>SETENAx（使能与除能寄存器）</h3><p>使能与除能寄存器控制外设中输入的中断请求是否被采用</p>
<table>
<thead>
<tr>
<th align="center">8个使能寄存器SETENAx(32位)</th>
<th align="center">基地址0xE000E100</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th align="center">8个除能寄存器CLRENAx(32位)</th>
<th align="center">基地址0xE000E180</th>
</tr>
</thead>
</table>
<p>当系统复位后,默认所有240个外部寄存器关闭,需要某个IRQn时,需要激活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*激活IRQ0*/</span><br><span class="line">LDR R0,=0xE000E100	</span><br><span class="line">MOV R1,#0x00000001	;每位对应一个中断,1号外部中断即为基地址偏移1位</span><br><span class="line">STR R1,[R0]</span><br></pre></td></tr></table></figure>

<p>因为为240个中断,共用到了8个寄存器,因此分为STENA0,STENA1…STENA7,每个都在基地址基础上偏移一个字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*激活IRQ40和IRQ233*/</span><br><span class="line">LDR R0,=0xE000E104	;40/32..1,因此使用的是第2个寄存器,要在0xE000E100基础上加1个字即4	</span><br><span class="line">MOV R1,#0x00000001	;40号IRQ为第41个,即为第二组中第9个(40-31),赋值0x00000009即可激活(?)</span><br><span class="line">STR R1,[R0]</span><br><span class="line"></span><br><span class="line">LDR R0,=0xE000E120	;233/32..7,因此使用的是第8个寄存器,要在0xE000E100基础上加8个字即32	</span><br><span class="line">MOV R1,#0x00000001	;233号IRQ为第224个,即为第二组中第10个(233-223),赋值0x00000010即可激活</span><br><span class="line">STR R1,[R0]</span><br></pre></td></tr></table></figure>

<p>因为涉及到寄存器组,因此若使用C定义则需要用到int型的数组便于访问中间的某个寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct	_NVIC</span><br><span class="line">&#123;</span><br><span class="line">	int ISER[8];	//中断使能寄存器</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SETPENDx-挂起解挂寄存器"><a href="#SETPENDx-挂起解挂寄存器" class="headerlink" title="SETPENDx(挂起解挂寄存器)"></a>SETPENDx(挂起解挂寄存器)</h3><table>
<thead>
<tr>
<th align="center">8个挂起寄存器SETPENDx(32位)</th>
<th align="center">基地址0xE000E200</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th align="center">8个解挂寄存器CLRPENDx(32位)</th>
<th align="center">基地址0xE000E280</th>
</tr>
</thead>
</table>
<p>CPU一次只能执行一个中断,在处理同级或高级优先度中断,或者被屏蔽时时,低优先级的将会在挂起寄存器中存储</p>
<p>挂起状态会一直保持,即使中断请求停止</p>
<p>一旦中断进入中断服务程序ISR准备执行时,系统会自动解挂</p>
<p><strong>外设的中断请求需要在挂起中手动清零</strong></p>
<p>使用方法同使能寄存器</p>
<h3 id="活动状态寄存器"><a href="#活动状态寄存器" class="headerlink" title="活动状态寄存器"></a>活动状态寄存器</h3><p>…</p>
<h3 id="PRI-n-优先级寄存器"><a href="#PRI-n-优先级寄存器" class="headerlink" title="PRI_n(优先级寄存器)"></a>PRI_n(优先级寄存器)</h3><p>基地址为0xE000E400,后面每个字节存储一个IRQn的优先级,范围(8位,但只有最高三位计数,其余为0)</p>
<p><strong>因此异常优先级取值只可能为0x00,0x20,0x40….0xE0</strong></p>
<table>
<thead>
<tr>
<th align="center">优先级寄存器PRI_n</th>
<th align="center">基地址0xE000E400</th>
</tr>
</thead>
</table>
<p>(IRQ0的优先级为0xE000E400,IRQ1的优先级为0xE000E401)</p>
<p>所有外部中断优先级的<strong>复位默认值</strong>为0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDR R0,=0xE000ED1F</span><br><span class="line">MOV R1,#0x20	;优先级010 000000设定为3</span><br><span class="line">STRB R1,[R0]	;注意是STRB,优先级为8位,必须按照字节存,同理,上一条如果要用LDR则必须为LDRB</span><br></pre></td></tr></table></figure>



<h3 id="STIR-软件触发寄存器"><a href="#STIR-软件触发寄存器" class="headerlink" title="STIR(软件触发寄存器)"></a>STIR(软件触发寄存器)</h3><p>当测试时还未外接设备时,使用该寄存器模拟中断输入</p>
<table>
<thead>
<tr>
<th align="center">软件触发寄存器STIR</th>
<th align="center">地址0xE000EF00</th>
</tr>
</thead>
</table>
<p>在该地址写入寄存器中断号即可产生相应中断</p>
<h2 id="RCC-复位与时钟控制"><a href="#RCC-复位与时钟控制" class="headerlink" title="RCC(复位与时钟控制)"></a>RCC(复位与时钟控制)</h2><p><strong>接口基地址:0x40021000</strong></p>
<table>
<thead>
<tr>
<th align="center">偏移</th>
<th align="center">寄存器</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00H</td>
<td align="center">CR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">04H</td>
<td align="center">CFGR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">08H</td>
<td align="center">CIR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0CH</td>
<td align="center">APB2RSTR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10H</td>
<td align="center">APB1RSTR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">14H</td>
<td align="center">AHBENR</td>
<td align="center">高速总线使能</td>
</tr>
<tr>
<td align="center">18H</td>
<td align="center">APB2ENR</td>
<td align="center">外部总线2使能</td>
</tr>
<tr>
<td align="center">1CH</td>
<td align="center">APB1ENR</td>
<td align="center">外部总线1使能</td>
</tr>
<tr>
<td align="center">20H</td>
<td align="center">BDCR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">24H</td>
<td align="center">CSR</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*汇编语言结构*/</span><br><span class="line">RCC	EQU	0x400021000</span><br><span class="line">RCC_CFGP	EQU	0x4</span><br><span class="line">...</span><br><span class="line">RCC_APB2RSTR	EQU 0x0C</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*调用*/</span><br><span class="line">LDR R0,=RCC</span><br><span class="line">LDR R0,[R0,#APB1RSTR]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*C语言结构*/</span><br><span class="line">headfile.h</span><br><span class="line">struct _RCC</span><br><span class="line">&#123;</span><br><span class="line">int CR;</span><br><span class="line">int CFGR;</span><br><span class="line">int CIR;</span><br><span class="line">int APB1RSTR;</span><br><span class="line">int APB2RSTR;</span><br><span class="line">int AHBENR;</span><br><span class="line">int APB2ENR;</span><br><span class="line">int APB1ENR;</span><br><span class="line">int BDCR;</span><br><span class="line">int CSR;</span><br><span class="line">&#125;;</span><br><span class="line">#define RCC((volatile struct _RCC*)0X40021000)</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">int main()&#123;</span><br><span class="line">RCC-&gt;APB2ENR=1&lt;&lt;2;(或者写作RCC-&gt;APB2ENR=0x00000100,位移符号的优先级高于=)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者都可看作是对基地址及其偏移进行宏定义便于后面调用,事实上名字可以任意取,为方便辨认统一规范</p>
<p><strong>时钟使能给对应控制的四位赋值4即可</strong></p>
<p>C语言中注意_RCC和RCC的区别, _RCC是实际上的地址,RCC是指向其的指针,在C中调用使用指针RCC</p>
<p>C使用结构体的优势:寄存器为32位,正好与int型相同,因此可用这种对应关系匹配地址</p>
<p>注意define语句**#define RCC((volatile struct _RCC*)0X40021000)**</p>
<p><strong>APB使能</strong></p>
<p>APB2:ADCx , GPIOx , TIM1,8 , USART1</p>
<h2 id="GPIO-通用IO口"><a href="#GPIO-通用IO口" class="headerlink" title="GPIO(通用IO口)"></a>GPIO(通用IO口)</h2><p>以STM32F103ZE为例,有7个16位GPIO口:GPIOA,GPIOB…….GPIOG</p>
<table>
<thead>
<tr>
<th align="center">GPIOn</th>
<th align="center">接口基地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GPIOA</td>
<td align="center">0x40010800</td>
</tr>
<tr>
<td align="center">GPIOB</td>
<td align="center">0x40010C00</td>
</tr>
<tr>
<td align="center">GPIOC</td>
<td align="center">0x40011000</td>
</tr>
<tr>
<td align="center">GPIOD</td>
<td align="center">0x40011400</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">GPIOn寄存器</th>
<th align="center">偏移地址</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GPIOx_CRL</td>
<td align="center">0x00</td>
<td align="center">GPIOx低8位输出属性</td>
</tr>
<tr>
<td align="center">GPIOx_CRH</td>
<td align="center">0x04</td>
<td align="center">GPIOx高8位输出属性</td>
</tr>
<tr>
<td align="center">GPIOx_IDR</td>
<td align="center">0x08</td>
<td align="center">GPIOx16位的输入值</td>
</tr>
<tr>
<td align="center">GPIOx_ODR</td>
<td align="center">0xC0</td>
<td align="center">GPIOx16位的输出值</td>
</tr>
</tbody></table>
<p>注:IDR口与ODR口仅使用低16位</p>
<p>CRL与CRH各管理8个管脚,每个管脚使用四位控制</p>
<p>四位控制如下</p>
<p><strong>低两位</strong></p>
<table>
<thead>
<tr>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">10</th>
<th align="center">11</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入模式(复位默认状态)</td>
<td align="center">输出模式(最大10MHz)</td>
<td align="center">输出模式(最大20MHz)</td>
<td align="center">输出模式(最大50MHz)</td>
</tr>
</tbody></table>
<p><strong>高两位</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>00</th>
<th>01</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>输入模式</td>
<td>模拟输入模式</td>
<td>浮空输入模式(复位默认状态)</td>
<td>上拉&#x2F;下拉输入模式</td>
<td>保留</td>
</tr>
<tr>
<td>输出模式</td>
<td>通用推挽输出模式</td>
<td>通用开漏输出模式</td>
<td>复用功能推挽输出</td>
<td>复用功能开漏输出</td>
</tr>
</tbody></table>
<p>输入模式采用10时,通过ODR寄存器辅助判断是上拉(1)还是下拉(0)</p>
<p>默认使用输出为0011(3),默认输出使用1000(8)	(或者为4:0100)</p>
<h2 id="UART-串口-通用异步收发传输器"><a href="#UART-串口-通用异步收发传输器" class="headerlink" title="UART(串口:通用异步收发传输器)"></a>UART(串口:通用异步收发传输器)</h2><p><strong>波特率</strong>:每秒传输码元的数目,一个比特位传输时长为码元周期,倒数为波特率</p>
<p>传输线在没有数据传输时保持1,起始0,中间8位数据,可加一个校验位(所有求和判断奇偶),后面停止1</p>
<p><strong>串口的时钟使能:APB2的15号位为USART1时钟使能</strong></p>
<table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">功能</th>
<th align="center">偏移地址</th>
<th align="center">复位值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">USART_SR</td>
<td align="center">状态寄存器</td>
<td align="center">0x0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">USART_DR</td>
<td align="center">数据寄存器</td>
<td align="center">0x4</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">USART_BRR</td>
<td align="center">波特率寄存器</td>
<td align="center">0x8</td>
<td align="center">0x0000</td>
</tr>
<tr>
<td align="center">USART_CR1</td>
<td align="center">控制寄存器</td>
<td align="center">0xC</td>
<td align="center">0x0000</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct _USART</span><br><span class="line">&#123;</span><br><span class="line">	int SR;</span><br><span class="line">	int DR;</span><br><span class="line">	int BRR;</span><br><span class="line">	int CR1;</span><br><span class="line">	int CR2;</span><br><span class="line">	int CR3;</span><br><span class="line">&#125;</span><br><span class="line">#define USART1((volatile struct _USART*)0x40013800)</span><br></pre></td></tr></table></figure>

<p>UART默认,PA9为输出,PA10为输入</p>
<p><strong>注:在默认情况下PA9必须置为0xB,PA10必须置为0x4!!!</strong></p>
<h3 id="USART-BRR-波特率寄存器"><a href="#USART-BRR-波特率寄存器" class="headerlink" title="USART_BRR(波特率寄存器)"></a>USART_BRR(波特率寄存器)</h3><p>共使用寄存器的16位,低四位存DIV_F(商),高四位存DIV_M(余数:小数部分)</p>
<p>波特率计算公式:baud&#x3D;f&#x2F;(16*DIV_M+DIV_F)</p>
<p>例如主频为8MHz,设置波特率为16kbps,则寄存器计算:</p>
<p>(8*10^6)&#x2F;(16*10^3)&#x2F;16&#x3D;31.25  (整数部分为31,小数部分为0.25)即设置寄存器为0x0000 01f4</p>
<h3 id="USART-CR-设置寄存器"><a href="#USART-CR-设置寄存器" class="headerlink" title="USART_CR(设置寄存器)"></a>USART_CR(设置寄存器)</h3><p>通用设置:0x200C(使能UART,8位数据,无校验位,收使能3,发使能2)</p>
<h2 id="AFIO-复用IO"><a href="#AFIO-复用IO" class="headerlink" title="AFIO(复用IO)"></a>AFIO(复用IO)</h2><p>STM32的每个中断都可作为外部中断输入,每个外部中断可设置独立的触发方式</p>
<p>NIVE支持16个IO中断,为EXT0-EXT15,后面的序号为映射GPIOxn的序号,即EXT0可选择GPIOA0.GPIOB0…</p>
<h3 id="AFIO-EXTICR1-外部中断配置寄存器1"><a href="#AFIO-EXTICR1-外部中断配置寄存器1" class="headerlink" title="AFIO_EXTICR1(外部中断配置寄存器1)"></a>AFIO_EXTICR1(外部中断配置寄存器1)</h3><p>32位只使用低16位,共四组,每组四位,每组决定是A,B,C,D中的哪个,每组中的四位(0-16)决定GPIOXn的n值</p>
<h2 id="IWD-看门狗单元"><a href="#IWD-看门狗单元" class="headerlink" title="IWD(看门狗单元)"></a>IWD(看门狗单元)</h2><p>一个倒计时复位的独立程序,每一定周期获取特定输入重置倒计时,用于监测程序是否正常循环</p>
<h2 id="硬件词汇表"><a href="#硬件词汇表" class="headerlink" title="硬件词汇表"></a>硬件词汇表</h2><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NIVE</td>
<td align="center">集成中断向量控制器</td>
</tr>
<tr>
<td align="center">GPIO</td>
<td align="center">通用输入输出端口</td>
</tr>
<tr>
<td align="center">HSE Osc</td>
<td align="center">高速外部晶体振荡器</td>
</tr>
<tr>
<td align="center">HSI RC</td>
<td align="center">内部RC振荡器</td>
</tr>
<tr>
<td align="center">CSS</td>
<td align="center">时钟监视系统</td>
</tr>
<tr>
<td align="center">AHB</td>
<td align="center">先进高速总线</td>
</tr>
<tr>
<td align="center">APB</td>
<td align="center">先进外部总线</td>
</tr>
<tr>
<td align="center">ENR</td>
<td align="center">使能寄存器</td>
</tr>
</tbody></table>
<h3 id="词根"><a href="#词根" class="headerlink" title="词根"></a>词根</h3><table>
<thead>
<tr>
<th align="center">词根</th>
<th align="center">含义集</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">先进</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">总线\波特</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">时钟\控制</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">数据</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">外部\使能</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">高速</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">内部\输入</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">低速</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">集成</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">输出</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">寄存器\复位\速率</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">速度\系统\状态</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/23/2023.3.23[STM32%E7%A1%AC%E4%BB%B6]/" data-id="clfl8f6iy0002fou3ef1o8ifd" data-title="STM32F103ZE部分硬件配置指南" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2023.3.17[汇编]" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/17/2023.3.17%5B%E6%B1%87%E7%BC%96%5D/" class="article-date">
  <time class="dt-published" datetime="2023-03-17T14:29:37.038Z" itemprop="datePublished">2023-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/17/2023.3.17%5B%E6%B1%87%E7%BC%96%5D/">基础汇编分享</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>注：仅作参考，与课本相异请以课本为准！</strong></p>
<p><strong>如有错误欢迎联系作者：</strong><a href="mailto:&#x54;&#x65;&#x34;&#77;&#x49;&#86;&#x61;&#108;&#x40;&#111;&#x75;&#116;&#x6c;&#111;&#x6f;&#107;&#x2e;&#99;&#111;&#109;">&#x54;&#x65;&#x34;&#77;&#x49;&#86;&#x61;&#108;&#x40;&#111;&#x75;&#116;&#x6c;&#111;&#x6f;&#107;&#x2e;&#99;&#111;&#109;</a></p>
<h1 id="单汇编"><a href="#单汇编" class="headerlink" title="单汇编"></a>单汇编</h1><h2 id="ARM存储系统访问"><a href="#ARM存储系统访问" class="headerlink" title="ARM存储系统访问"></a>ARM存储系统访问</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	AREA RESET ,CODE</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __initial_sp	</span><br><span class="line">	DCD Reset_Handler	</span><br><span class="line">		</span><br><span class="line">Reset_Handler PROC		</span><br><span class="line">	NOP</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	ENDP</span><br><span class="line"></span><br><span class="line">	AREA STACK,DATA		</span><br><span class="line">	SPACE 0x200			</span><br><span class="line">__initial_sp</span><br><span class="line">						</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>



<h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><p>ROM 代码区 0x08000000</p>
<p>RAM 数据区  0x02000000</p>
<p>代码本身也按照0x格式存储在代码区，但例如DCB,DCW,DCD等伪指令不占用</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>char DCB		（define char byte） 1</p>
<p>short DCW		(short)			2</p>
<p>long DCD	（double word）	4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X DCB 5 </span><br><span class="line">y DCW 0x1234</span><br><span class="line">z </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	AREA RESET ,CODE</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __initial_sp	//从0X08000000开始，两个四字节的定义</span><br><span class="line">	DCD Reset_Handler</span><br><span class="line">		</span><br><span class="line">Reset_Handler PROC</span><br><span class="line">	NOP					//实际NOP从0x08000008开始</span><br><span class="line">	</span><br><span class="line">X	DCB 5</span><br><span class="line">Y	DCW 0xAB</span><br><span class="line">Z 	DCD 0X12345678</span><br><span class="line">	</span><br><span class="line">	B .</span><br><span class="line">	ENDP</span><br><span class="line">		</span><br><span class="line">	AREA STACK,DATA</span><br><span class="line">	SPACE 0x100</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		END</span><br></pre></td></tr></table></figure>

<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>32位地址32位总线，32&#x2F;8&#x3D;4，即一次可传输四个字节，每次取址都是四的倍数，要求尽可能在一次取址中取完，对于不满的进行对其补0</p>
<p>如 DCW 0xAB(两字节) DCD 0x12345678（四字节），假设AB起始地址已对齐，则</p>
<p>AB 00 00 00 78 56 34 12 (AB 00为数据 00 00为对齐补0)</p>
<p>再例 DCB 5 DCD 12345678,则</p>
<p>07 00 00 00 78 56 34 12（00 00 00 00为补齐）</p>
<p>DCB 5 DCW 0xAB，则</p>
<p>05 00 AB 00</p>
<h3 id="变量与数组"><a href="#变量与数组" class="headerlink" title="变量与数组"></a>变量与数组</h3><p>X DCB 0X5</p>
<p>X存储的为整个数据的首地址</p>
<p>X DCB 1,2,3</p>
<p>含义参见C中数组定义</p>
<h3 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h3><p>A SPACE 16</p>
<p>分配16个字节的空间，初始赋值为0</p>
<h3 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h3><h4 id="R15-PC"><a href="#R15-PC" class="headerlink" title="R15-PC"></a>R15-PC</h4><p>存储程序指针，永远指向正在执行的指令之后一条指令的位置（下一指令组成的地址的开头）</p>
<h4 id="R14-LR"><a href="#R14-LR" class="headerlink" title="R14-LR"></a>R14-LR</h4><p>使用BL跳转指令时记录执行完外部函数跳转回来的位置</p>
<h4 id="R13-SP"><a href="#R13-SP" class="headerlink" title="R13-SP"></a>R13-SP</h4><p>栈（stack）指针（pointer），初始指向0x02000000</p>
<h3 id="MOV-Move"><a href="#MOV-Move" class="headerlink" title="MOV(Move)"></a>MOV(Move)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R1,R2		//R1=R2</span><br><span class="line">MOV R3 , #0X12	//R3=18</span><br></pre></td></tr></table></figure>

<p>#为立即数，范围为0x00000000<del>0x11111111（0</del>255）即一字节</p>
<h3 id="LDR-Load"><a href="#LDR-Load" class="headerlink" title="LDR(Load)"></a>LDR(Load)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LDR R0,X	//用法同MOV,将X开始的四个字节内容给R0</span><br><span class="line">LDR R0,=X	//将X的地址给R0</span><br><span class="line">LDR R0,=0x0A	立即数赋值</span><br><span class="line">LDR R1,[0X0800000A]	//将目标地址开始的四个字节的内容加载至R1</span><br><span class="line">LDR R0,[R3]		//将R3地址起始的四字节加载至R0</span><br><span class="line">LDR R0,[R4,#4]	//R4为基址，#4为偏址，相加的和为最终地址（类似数组地址加法）</span><br><span class="line">LDR R0,[R5,R6]	//同上一个,但是以R6数据作为偏移</span><br></pre></td></tr></table></figure>

<p>LDR赋值范围为四字节（32位）</p>
<p>注意取出的四字节赋值后依旧遵循高低位的排列顺序！！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【后索引】LDR R1,[R2],#4	//在执行完常规R2加载至R1后令R2+4（可实现连续读取）</span><br><span class="line">【前索引】LDR R1，[R2,#4]!	//在执行完R2+4加载至R1后令R2+4</span><br></pre></td></tr></table></figure>

<p>前后索引可参考c语言i++和++i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDRB Rd,[Rn,offset]		//从地址后取字节</span><br><span class="line">LDRH Rd,[Rn,offset]		//从地址后取半字</span><br><span class="line">LDRD RdL,RdH[Rn,offset]		//从地址后取双字（双子16字节需要两个寄存器存储）</span><br></pre></td></tr></table></figure>

<h3 id="STR-Store"><a href="#STR-Store" class="headerlink" title="STR(Store)"></a>STR(Store)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR R1,[R2]			//将R1存储至R2所在地址</span><br><span class="line">和LDR一样存在STRH,STRB,STRD等变化</span><br></pre></td></tr></table></figure>

<p>和LDR的区分可以用从寄存器到存储器是“存储”，从存储器到寄存器是“加载”</p>
<h3 id="LDM-load-Multi"><a href="#LDM-load-Multi" class="headerlink" title="LDM(load Multi-)"></a>LDM(load Multi-)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LDM R1,&#123;R2,R3,R4&#125;	//从R2地址开始将后面依次三个字赋给R2 R3 R4</span><br><span class="line">&#123;	Z DCD 0X11111111,0X22222222,0X33333333</span><br><span class="line">	LDR R1,=Z				//R2 R3 R4依次为三个值</span><br><span class="line">	LDM R1,&#123;R2,R3,R4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：与排列顺序无关，系统会制动从小到大排序，也可使用{R2-R4表示范围}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R1,&#123;R1,R2,R3&#125;		//同普通LDM</span><br><span class="line">LDMDB R1,&#123;R1,R2,R3&#125;		//同LDM，但是递减</span><br><span class="line">LDMIA R1!,&#123;R1,R2,R3&#125;	//在赋值后(After)R1增加(Increase)12</span><br><span class="line">LDMDB R1!,&#123;R1,R2,R3&#125;	//在赋值前(Before)R1减小(Decrease)12</span><br></pre></td></tr></table></figure>

<p>！意味改变地址，且地址的改变量都等于后面跟随的长度，为4的倍数</p>
<h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0&#125;	//将R0中的数据置于栈中，并令R13-sp指针R13=R13-4</span><br><span class="line">POP &#123;R0&#125;	//为push的逆操作，将R13后的四个字节置于R0并R13=R13+4</span><br><span class="line">PUSH &#123;R2,R3,R4&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算数逻辑运算"><a href="#算数逻辑运算" class="headerlink" title="算数逻辑运算"></a>算数逻辑运算</h2><h3 id="标志位xPSR"><a href="#标志位xPSR" class="headerlink" title="标志位xPSR"></a>标志位xPSR</h3><p>N(Negative)	负数位，运算结果为负数则置为1</p>
<p>Z(Zero)			零位，运算结果为零则置为1</p>
<p>C(Carry)		  进位，最高位产生进位置为1</p>
<p>V(Overflow)	溢出，运算超过寄存器范围则产生溢出置1</p>
<p>标志位仅在有相关指令时改变，否则一直保留上一个数据</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>正数的补码为本身，负数的补码(32位补码)为0x100000000-|负数|</p>
<p>【8位补码】-1-&gt;(0x100-1)-&gt;0xFF</p>
<p>【32位补码】-8-&gt;(0x100000000-8)-&gt;0XFFFFFFF8 -3-&gt;0xFFFFFFFD -1-&gt;0xFFFFFFFF</p>
<p>R的储存范围为-2^31~2^31-1,正好补码填充2^32整个数域</p>
<p>对于32位而言，0x80000000为所能表示最小的数(0x8&#x3D;1000)，大于此值的都为负数且递增</p>
<p>N：补码的最高位为符号位，置1为负数（二进制表示），与N相同</p>
<p>C：原码加对应的补码输出为0，C为0(0100+1100-&gt;10000)，C为0</p>
<p>溢出是表示数结果判断是否在范围内，进位是看相加后未转换的结果是否进位</p>
<p>二进制负数补码可简化为正数取反加1</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADD R1,R2		//R1=R1+R2</span><br><span class="line">ADD R1,R2,R3	//R1=R2+R3</span><br><span class="line">ADD R1,#imm		//R1=R1+imm</span><br><span class="line">ADD R1,R2,#imm	//R1=R2+imm</span><br><span class="line">ADDS			</span><br></pre></td></tr></table></figure>

<p>imm范围为0x000~0xFFF</p>
<p>ADDS除了正常的ADD效果，还影响标志位</p>
<h3 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC R1,R2		//R1=R1+R2+C</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*用32位寄存器设计一个64位加法程序R*/</span><br><span class="line">/*R1R2表示第一个加数的高低位，同理R3R4,用R5R6表示结果的高低位*/</span><br><span class="line">ADDS R6,R2,R4</span><br><span class="line">ADC R5,R1,R3</span><br><span class="line">/*即如果有进位R2+R4有进位，则C置1，在后面高位运算时加上进位的1*/</span><br></pre></td></tr></table></figure>

<h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB R1,R2	//R1=R1-R2</span><br><span class="line">SBC R1,R2	//R1=R1-R2-C(理解同ADC)</span><br></pre></td></tr></table></figure>

<h3 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MUL R1,R2		//R1=R1*R2</span><br><span class="line">MUL R1,R2,R3	//R1=R2*R3</span><br></pre></td></tr></table></figure>

<h3 id="DIV"><a href="#DIV" class="headerlink" title="DIV"></a>DIV</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UDIV R1,R2	//R1=R1/R2 无符号除法，所有数据都当作当前的数使用</span><br><span class="line">SDIV R1,R2	//R1=R1/R2 有符号除法，最高位当作符号位，其余的为数据位</span><br></pre></td></tr></table></figure>

<p>注意加减可使用立即数,乘除不可使用立即数</p>
<h3 id="CMP"><a href="#CMP" class="headerlink" title="CMP"></a>CMP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP R1,R2	//R1-R2,不影响寄存器的值，但影响标志位，可通过Z的值判断是否相等</span><br></pre></td></tr></table></figure>

<h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AND R1,R2	//R1=R1&amp;R2 按位与：R1的每一位都是R1R1相应各位的与</span><br><span class="line">AND R1,R2,R3</span><br><span class="line">AND R1,R2,#imm</span><br><span class="line">ANDS		//同AND,但影响标志位</span><br></pre></td></tr></table></figure>

<h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ORR R1,R2	//R1=R1|R2	按位或：同按位与</span><br><span class="line">ORR R1,R2,R3</span><br><span class="line">ORR R1,R2,#imm</span><br></pre></td></tr></table></figure>

<h3 id="TST"><a href="#TST" class="headerlink" title="TST"></a>TST</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TST R1,R2	//R1&amp;R2,类似ANDS,影响标志位，但不影响寄存器</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*检测某一个寄存器的第三位位输入是否为1*/</span><br><span class="line">LDR R0,=0x01110010</span><br><span class="line">LDR R1,=0x00100000</span><br><span class="line">TST R1,R2</span><br><span class="line">/*其余位都被R1中的0相与变成0,只有第三位,当为1时整体不为0 Z=0,当为0时整体为0 Z=1,达成判断第三位的功能*/</span><br></pre></td></tr></table></figure>

<h3 id="LSL-LSR"><a href="#LSL-LSR" class="headerlink" title="LSL LSR"></a>LSL LSR</h3><p>（Logic shift left&#x2F;right	逻辑左移&#x2F;右移）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LSL R1,R2,#1	//R1=R2&lt;&lt;1</span><br><span class="line">LSR R1,R2 		//R1=R1&gt;&gt;R2</span><br></pre></td></tr></table></figure>

<p>逻辑左移1位:整体向左移动一位，移出去的成为C，新加入最低位补0</p>
<p>逻辑左移n位:等同于n次左移一位</p>
<p>右移同理，最高位补0</p>
<p>10001101	(&lt;&lt;2)	-&gt;	00110100 C&#x3D;0</p>
<h3 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h3><p>(Arithmetic Shift Right	算数右移)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASR R1,R2		</span><br></pre></td></tr></table></figure>

<p>同逻辑位移，但保留最高位符号位</p>
<p>110001111 (&gt;&gt;2)	-&gt;	100100011</p>
<p>左移相当于乘2，右移相当于除2，无符号可直接用LSR&#x2F;L，但有符号必须用ASR</p>
<p>没有ASL指令，ASL和LSL指令完全一致</p>
<h3 id="ROR"><a href="#ROR" class="headerlink" title="ROR"></a>ROR</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROR R1,R2</span><br></pre></td></tr></table></figure>

<p>循环位移，移出的填到高位，同时给C</p>
<h3 id="RRX"><a href="#RRX" class="headerlink" title="RRX"></a>RRX</h3><p>同ROR，但将C当作最低位参与循环</p>
<h2 id="转移控制指令"><a href="#转移控制指令" class="headerlink" title="转移控制指令"></a>转移控制指令</h2><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>（Branch 跳转指令）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B L1		//跳转到L1标号的位置(后接地址)</span><br><span class="line">BX R1		//跳转到寄存器R1记录的地址(后接寄存器)</span><br><span class="line">BL L1		//跳转并记录下一个地址记录在R14(LR)中,在执行完外部指令时回到该位置(在外部指令后加BX LR)</span><br><span class="line">BLX R1		//同BL,但返回的标志地址存在R1而非LR中</span><br></pre></td></tr></table></figure>

<p>B	.的意义是在此句中循环,等同与LL		B LL</p>
<h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><p>在常规指令后加上判断符后缀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EQ	相等	Z==1</span><br><span class="line">NE  不等	Z！=1</span><br><span class="line">HI	无符号大于		 C==1&amp;&amp;Z==0</span><br><span class="line">LS 	无符号小于等于		C==0&amp;&amp;Z==1</span><br><span class="line">GE 	无符号大于等于		N==V</span><br><span class="line">LT	带符号小于		 N!=V</span><br><span class="line">GT	带符号大于		 Z==0&amp;&amp;N==V</span><br><span class="line">LE	带符号小于等于		Z==1||N!=V</span><br></pre></td></tr></table></figure>

<p>不需要专门记忆涉及的标志位，只需要使用CMP指令，再在下一条指令后加条件即可</p>
<h2 id="流程图结构"><a href="#流程图结构" class="headerlink" title="流程图结构"></a>流程图结构</h2><p>流程图不可使用寄存器作为变量，在写代码的时候变量替换为寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*计算1~100的和*/</span><br><span class="line">	MOV R0 ,#0</span><br><span class="line">	MOV R1 ,#0</span><br><span class="line">loop1</span><br><span class="line">	CMP R1,#100</span><br><span class="line">	BHI end		//即为B+HI,在大于时(R1&gt;100)返回</span><br><span class="line">	ADD R0,R1</span><br><span class="line">	ADD R1,#1</span><br><span class="line">	B loop1</span><br><span class="line">	</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*编写求和函数R0=Sum&#123;R0,R1,R2&#125;*/</span><br><span class="line">	LDR R0,=0</span><br><span class="line">	LDR R1,=1</span><br><span class="line">    LDR R2,=2</span><br><span class="line">    BL SUM</span><br><span class="line">    ADD R0,R0</span><br><span class="line">        </span><br><span class="line">SUM proc</span><br><span class="line">	ADD R0,R1</span><br><span class="line">	ADD RO,R2</span><br><span class="line">	BX LR</span><br><span class="line">	endp</span><br><span class="line">/*BL和BX的搭配使得可以跳转到调用的函数位置并在函数执行完回到LR指向的调用点*/</span><br><span class="line">/*或者用MOV PC LR也可以将程序当前执行指针指向LR存储位置返回*/</span><br><span class="line">/*规范格式要在函数开始与结束的位置加上proc与endp,但并不强制*/</span><br><span class="line">/*规范的子过程要在主过程外,此时需加上PROC ENDP标识符*/</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>在一个函数中调用另一个函数，不可使用LR指针返回，会覆盖上一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*使用寄存器保护LR不被覆盖*/</span><br><span class="line">	BL loop1</span><br><span class="line">	</span><br><span class="line">loop1</span><br><span class="line">	MOV R0 ，LR	//将LR存储到R0中保护</span><br><span class="line">	BL loop2</span><br><span class="line">	BX R0		//返回R0</span><br><span class="line">	</span><br><span class="line">loop2</span><br><span class="line">	BX LR</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*使用堆栈让LR可逆向读取*/</span><br><span class="line">	BL loop1</span><br><span class="line">	</span><br><span class="line">loop1</span><br><span class="line">	PUSH(LR)	//将LR置于堆栈中</span><br><span class="line">	BL loop2	</span><br><span class="line">	POP (PC)	//读取堆栈，直接让程序指针为上一个LR(或者POP(LR)	BX(LR))</span><br><span class="line">	</span><br><span class="line">loop2</span><br><span class="line">	BL LR</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>三种传递方式：寄存器，存储器，堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*寄存器传参见上例*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*存储器传参*/</span><br><span class="line">/*将三个数据的和放到第四个位置*/</span><br><span class="line">XX	DCD 0x12,0X34,0X56,0</span><br><span class="line">	BL loop1</span><br><span class="line">	</span><br><span class="line">loop </span><br><span class="line">	LDR R0,=XX</span><br><span class="line">	LDR R1 [R0]</span><br><span class="line">	LDR R2 [R0,#4]</span><br><span class="line">	LDR R3 [R0,#8]</span><br><span class="line">	ADD R1,R2</span><br><span class="line">	ADD R1,R3</span><br><span class="line">	STR R1 [R0,#12]		//错误,在memory中可以看到R0,#12区域任然为0</span><br><span class="line">	BX LR</span><br><span class="line">/*将数据所在的存储器地址传输到寄存器中，再通过对地址的运算访问数据*/</span><br></pre></td></tr></table></figure>

<p>STR指令写入的R0,#12为ROM区(CODE),为仅读区域不可写入存储的R1</p>
<p>需要在DATA区开辟区域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*完整代码*/</span><br><span class="line">	AREA RESET ,CODE</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __initial_sp	//代码在0X08000000,定义了一个位于0X02000200地址的__initial_sp</span><br><span class="line">	DCD Reset_Handler	//0x08000004,存的是程序的入口地址即PC指针(R15)</span><br><span class="line">		</span><br><span class="line">Reset_Handler PROC		//此时起始为0x08000008</span><br><span class="line">	NOP</span><br><span class="line">XX	DCD 0x12,0X34,0X56,0</span><br><span class="line">	BL loop1</span><br><span class="line">	B .</span><br><span class="line">	ENDP</span><br><span class="line">	</span><br><span class="line">loop </span><br><span class="line">	LDR R0,=XX</span><br><span class="line">	LDR R1 [R0]</span><br><span class="line">	LDR R2 [R0,#4]</span><br><span class="line">	LDR R3 [R0,#8]</span><br><span class="line">	ADD R1,R2</span><br><span class="line">	ADD R1,R3</span><br><span class="line">	LDR R5,=ZZ			//将一个RAM区的地址ZZ赋给R5</span><br><span class="line">	STR R1 [R5]			//将R1存到R5地址,即ZZ的RAM区</span><br><span class="line">	BX LR</span><br><span class="line">						//DATA区的起始地址为0x02000000</span><br><span class="line">	AREA STACK,DATA		//定义了一个名叫STACK(堆栈)的DATA区</span><br><span class="line">	SPACE 0x200			//为STACK开辟了一个200字节的空间</span><br><span class="line">__initial_sp</span><br><span class="line">						//接着上面的STACK区继续分配空间</span><br><span class="line">	AREA dat,DATA		//定义了一个名叫dat的DATA区</span><br><span class="line">ZZ	DCD 0				//因为上面的STACK分配了100字节的空间,dat的起始即ZZ地址为0x02000100</span><br><span class="line">X	DCD	0				//0x02000104</span><br><span class="line">Y	DCD	0</span><br><span class="line"></span><br><span class="line">		END</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*通过堆栈传输数据*/</span><br><span class="line">    LDR R1,=0x12</span><br><span class="line">    PUSH &#123;R1&#125;</span><br><span class="line">    LDR R1,=0x34</span><br><span class="line">    PUSH &#123;R1&#125;</span><br><span class="line">    LDR R1,=0x56</span><br><span class="line">    PUSH &#123;R1&#125;			//分别将三个加数传输入堆栈</span><br><span class="line">    BL loop</span><br><span class="line">    POP	&#123;R0&#125;			//将函数执行完成的结果从堆栈取出放入R0</span><br><span class="line">    B .</span><br><span class="line"></span><br><span class="line">loop</span><br><span class="line">	POP&#123;R1,R2,R3&#125;		//从堆栈中取出前三个数值赋给R1,R2,R3</span><br><span class="line">	ADD R1,R2</span><br><span class="line">	ADD R1,R3</span><br><span class="line">	PUSH &#123;R1&#125;			//将和返回堆栈</span><br><span class="line">	BX LR</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="联合汇编"><a href="#联合汇编" class="headerlink" title="联合汇编"></a>联合汇编</h1><h2 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*汇编启动代码starup.s*/</span><br><span class="line">AREA RESET ,CODE</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __initial_sp	</span><br><span class="line">	DCD Reset_Handler	//启动文件,地址永远为0x08000004</span><br><span class="line">		</span><br><span class="line">Reset_Handler PROC	</span><br><span class="line">	NOP</span><br><span class="line"></span><br><span class="line">	IMPORT main		//伪指令,告诉汇编程序该地址不在汇编当中,将main函数的地址注入到汇编当中</span><br><span class="line">	LDR R0,=mian	//将注入的main函数地址赋给R0</span><br><span class="line">	BX R0			//跳转到R0位置,即main函数所在位置</span><br><span class="line">	</span><br><span class="line">	B .</span><br><span class="line">	ENDP</span><br><span class="line">	</span><br><span class="line">	AREA STACK,DATA		</span><br><span class="line">	SPACE 0x200			</span><br><span class="line">__initial_sp</span><br><span class="line">			</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*C程序框架main.c*/</span><br><span class="line">/*循环框架*/</span><br><span class="line">void main()&#123;</span><br><span class="line">	......</span><br><span class="line">	while(1);	//需要一个程序循环,若无内循环则使用while循环,坐拥类似与B .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上main的意义和之前使用汇编函数(子过程)的意义一致,但前面的IMPORT决定它是外部函数</p>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><h3 id="汇编调用C"><a href="#汇编调用C" class="headerlink" title="汇编调用C"></a>汇编调用C</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*C返回框架*/</span><br><span class="line">void main()&#123;</span><br><span class="line">	......</span><br><span class="line">	return;		//return返回的地址为LR地址等效于BX,这要求转到该函数时指定LR(如BLX),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C调用汇编"><a href="#C调用汇编" class="headerlink" title="C调用汇编"></a>C调用汇编</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*对应汇编调用部分*/</span><br><span class="line">	Reset_Handler PROC		//调用C的汇编部分</span><br><span class="line">    NOP</span><br><span class="line">	IMPORT main()</span><br><span class="line">	LDR R0,=main()</span><br><span class="line">	BLX R0</span><br><span class="line">	ENDP</span><br><span class="line">	</span><br><span class="line">	EXPORT asm_func			//汇编中也需要声明该子过程供外部函数调用</span><br><span class="line">asm_func PROC</span><br><span class="line">	BX LR			</span><br><span class="line">	ENDP</span><br><span class="line">	</span><br><span class="line">/*C调用框架*/</span><br><span class="line">extern void asm_func();		//调用需声明汇编中函数(子过程)</span><br><span class="line">void main()&#123;</span><br><span class="line">	asm_func();</span><br><span class="line">	return;					</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*汇编调用使用INPORT声明,被调用使用EXPORT声明,C调用需要extern声明*/</span><br></pre></td></tr></table></figure>

<p>C在编译成汇编的时候,会通过PUSH保护调用C程序的汇编指针,防止C运行的时候LR指针发生覆盖</p>
<p>可理解为堆栈的出入的有序性使得每个调用与返回的指针一一匹配,类似这种括号的有序匹配形式{ [ ( ) ] }</p>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>传参时,参数列表的前四个参数保存在R0~R3中,后面的需要手动按先后顺序保留在堆栈中</p>
<h3 id="汇编向C传参"><a href="#汇编向C传参" class="headerlink" title="汇编向C传参"></a>汇编向C传参</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*C调用汇编参数*/</span><br><span class="line">/*C部分*/</span><br><span class="line">int sum</span><br><span class="line">void C_FUNC(int a,intb,int c,int d,inte,int f,int g)&#123;</span><br><span class="line">	sum=a+b+c+d+e+f+g;</span><br><span class="line">	while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*汇编部分*/</span><br><span class="line">	LDR R0,=0</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	LDR R6,=0</span><br><span class="line">	PUSH &#123;R4~R6&#125;		//R0~R3四个参数的值可直接传递,剩下的三个需要手动入栈</span><br><span class="line">	IMPORT C_FUNC</span><br><span class="line">	LDR R9,=C_FUNC</span><br><span class="line">	BX R9</span><br><span class="line"></span><br><span class="line">/*sum可读写,因此存在RAM区,可在0x20000000附近找到*/</span><br></pre></td></tr></table></figure>

<p>关于参数赋值的顺序,通过寄存器的R0,R1,R2,R3(?)将依次先后赋给c参数列表的前四个变量,后面通过堆栈传递的参数则遵照:先入栈,后取出的规律</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*参数传递赋值演示*/</span><br><span class="line">/*c的参数列表*/</span><br><span class="line">(int a,int b,int c,int d,int e,int f,int g)</span><br><span class="line">/*汇编的传参列表*/</span><br><span class="line">X DCB 1,2,3,4,5,6,7</span><br><span class="line">LDR R10,=X</span><br><span class="line">LDR R0,[R10]</span><br><span class="line">LDR R1,[R10,#1]</span><br><span class="line">LDR R1,[R10,#2]</span><br><span class="line">LDR R1,[R10,#3]</span><br><span class="line">LDR R11,[R10,#4]</span><br><span class="line">PUSH &#123;R11&#125;</span><br><span class="line">LDR R11,[R10,#5]</span><br><span class="line">PUSH &#123;R11&#125;</span><br><span class="line">LDR R11,[R10,#6]</span><br><span class="line">PUSH &#123;R11&#125;</span><br><span class="line">/*则C中abcdefg的数分别为1234765,注意后面为倒叙*/</span><br><span class="line">/*使用push&#123;R1,R2,R3&#125;则等同于依次将R3,R2,R1入栈*/</span><br></pre></td></tr></table></figure>



<h3 id="C向汇编传参"><a href="#C向汇编传参" class="headerlink" title="C向汇编传参"></a>C向汇编传参</h3><h4 id="通过RETURN传参"><a href="#通过RETURN传参" class="headerlink" title="通过RETURN传参"></a>通过RETURN传参</h4><p>C使用return返回的数据一定在R0中</p>
<h4 id="通过函数传参"><a href="#通过函数传参" class="headerlink" title="通过函数传参"></a>通过函数传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*C中函数形式*/</span><br><span class="line">sum=sum_s(1,2,3,4,5,6)</span><br><span class="line">/*汇编中相应求和函数*/</span><br><span class="line">	ADD R9,R0</span><br><span class="line">	ADD R9,R1</span><br><span class="line">	ADD R9,R2</span><br><span class="line">	ADD R9,R3</span><br><span class="line">	POP &#123;R4&#125;</span><br><span class="line">	ADD R9,R4</span><br><span class="line">	POP &#123;R5&#125;</span><br><span class="line">	......</span><br><span class="line">/*传递到汇编中时,前四个参数分别存在R0~R3中,剩下的自动入栈,需要使用POP取出使用,注意顺序*/</span><br></pre></td></tr></table></figure>

<h1 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h1><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="T1：求n位数和"><a href="#T1：求n位数和" class="headerlink" title="T1：求n位数和"></a>T1：求n位数和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*完整代码*/</span><br><span class="line">	AREA RESET ,CODE</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __initial_sp	</span><br><span class="line">	DCD Reset_Handler	</span><br><span class="line">		</span><br><span class="line">Reset_Handler PROC	</span><br><span class="line">	NOP</span><br><span class="line">Z	DCD 180238			//目标计算数字</span><br><span class="line">	LDR R0,Z	;NUM	//先讲Z地址的数据赋给R0</span><br><span class="line">	LDR R1,=6	;i		//R1为循环计数器i,循环六次故共六位,i=6</span><br><span class="line">	LDR R2,=0	;SUM	//R2为求和寄存器</span><br><span class="line">	</span><br><span class="line">	LDR R10,=10			//因为下一步的除法计算需要除10,但UNIV没有立即数,需要指定一个寄存器存10</span><br><span class="line">	</span><br><span class="line">LOOP</span><br><span class="line">	UDIV R3,R0,R10;R3=R0/R10	//R3为除10后取整</span><br><span class="line">	MUL R4,R3,R10				//R4为减去最后一位剩下的数位</span><br><span class="line">	SUB R5,R0,R4				//R5为原数据减去R4,即最低位</span><br><span class="line">	ADD R2,R5					//取出最低位R5后存到sum当中</span><br><span class="line">	LDR R0,[R3]					//将去除最低位后的R0给R3,参与下次循环</span><br><span class="line">	</span><br><span class="line">	SUB R1,#1					//计数位-1</span><br><span class="line">	CMP R1,#0					//比较是否R1是否不为0,不为零则循环</span><br><span class="line">	BNE LOOP</span><br><span class="line">	</span><br><span class="line">	LDR R9,=RESULT				//让R9等于RESULT的地址,STR只能用寄存器</span><br><span class="line">	STR R2,[R9]					//将结果存到RESULT空间(0x20000200)</span><br><span class="line">	</span><br><span class="line">	B .</span><br><span class="line">	ENDP</span><br><span class="line">	</span><br><span class="line">	AREA STACK,DATA		</span><br><span class="line">	SPACE 0x200			</span><br><span class="line">__initial_sp</span><br><span class="line">RESULT DCD 0					//在存储区说明一个RESULT的空间以存储结果			</span><br><span class="line">		END</span><br><span class="line"></span><br><span class="line">/*汇编没有取模指令,因此使用去掉最低位的减法得到余数*/</span><br><span class="line">/*不一定只能求10的余数,如13%3,13-[13/3]*3=1	*/</span><br></pre></td></tr></table></figure>

<h2 id="T2-10000以内3倍数求和"><a href="#T2-10000以内3倍数求和" class="headerlink" title="T2:10000以内3倍数求和"></a>T2:10000以内3倍数求和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	AREA RESET ,CODE</span><br><span class="line">	EXPORT __Vectors</span><br><span class="line">	EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">	DCD __initial_sp	</span><br><span class="line">	DCD Reset_Handler	</span><br><span class="line">		</span><br><span class="line">Reset_Handler PROC		</span><br><span class="line">	</span><br><span class="line">	NOP</span><br><span class="line">	LDR R0,=0			//R0为和SUM</span><br><span class="line">	LDR R1,=1;i			//R1为从1开始递增的i</span><br><span class="line">	LDR R10,=3;temp3	//R3为除法需要的3</span><br><span class="line">	LDR R11,=10000		//R11为总数10000</span><br><span class="line">	</span><br><span class="line">LOOP					//模三判断模块</span><br><span class="line">	UDIV R2,R1,R10		//R2为[i/10]</span><br><span class="line">	MUL	R3,R2,R10		</span><br><span class="line">	SUB R4,R1,R3		//余数=R1-R2*3</span><br><span class="line">	</span><br><span class="line">	CMP R4,#0			//是否余数为0</span><br><span class="line">	ADDEQ R0,R1			//为O则i可被整除加入R0</span><br><span class="line">	</span><br><span class="line">	CMP R1,R11			//比较是否加到10000结束循环</span><br><span class="line">	ADDNE R1,#1</span><br><span class="line">	BNE LOOP</span><br><span class="line">	</span><br><span class="line">	LDR R10,=SUM		//存到SUM中</span><br><span class="line">	STR R0,[R10]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	B .</span><br><span class="line">	ENDP</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	AREA STACK,DATA		</span><br><span class="line">	SPACE 0x200			</span><br><span class="line">__initial_sp</span><br><span class="line">SUM DCD 0				//存储位置SUM的声明</span><br><span class="line">						</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/17/2023.3.17[%E6%B1%87%E7%BC%96]/" data-id="clfl8f6iu0001fou3axzi4nb8" data-title="基础汇编分享" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2023.3.17[第一篇博客]" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/17/2023.3.17%5B%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%5D/" class="article-date">
  <time class="dt-published" datetime="2023-03-17T12:58:41.670Z" itemprop="datePublished">2023-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/17/2023.3.17%5B%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%5D/">开始</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="第一篇个人博客"><a href="#第一篇个人博客" class="headerlink" title="第一篇个人博客"></a>第一篇个人博客</h2><h3 id="2023-3-17"><a href="#2023-3-17" class="headerlink" title="2023.3.17"></a>2023.3.17</h3><p>​		难得有空来倒腾一下个人网站的搭建。一直都挺想拥有一个独立的分享渠道，今天算是终于成功了。</p>
<p>​		我的专业是陕西某带专的通信工程，除了苦逼的捣鼓板子，倒也对其他各种奇奇怪怪的东西感兴趣。建立这个个人博客的初衷也是为了分享与结识一些志同道合的同路人。换个层面，这也倒是对自己的某种鞭策。人都有原始的分享欲，这某种程度上也会激励我去不断学习新东西。倘若在这个途中能够帮助到一些人，也是我的荣幸。</p>
<p>​		从小时候我就是一个对技术极端热爱的人，但随着学的愈多，才愈发现自己的无知。有时望及一个知识体系的庞大与宏伟，便会真真切切地感受到自己的渺小，不过随之伴生的还有一种难言的征服欲。不可避免的，在攀爬这座高峰的路上，会遇到或大或小的障碍，我们的热情也会在一次次挫败中逐渐消散，可这条路上并不只有挫折。至今我也不会忘记第一次运行一个完整的C程序，第一次跑通汇编，第一次在板子上点亮LED灯，第一次成功搭建一台图灵机……这些里程碑式的成就，无时无刻不在为我提供在这条路上所最重要的东西：<strong>热情</strong>。</p>
<p>​		有时会对未来充满迷茫，不知道自己在走出校门后将何去何从；亦或是惶恐于自己将成为茫茫人海中碌碌无为的那一个。曾经我也有宏大的梦想，但也逐渐认清有些东西并不是人可左右。不过也许我可以在走进坟墓前，做并做成一些我所热爱的小事。人所最幸福之事便是拥有一个自己的小世界，并有一群为之共同前进的同伴。我曾经怀疑自己行为的意义，现在才逐渐意识到，意义是属于自己的，它与他人，与社会，与其他任何事都没有关系。</p>
<p>​		今天就写到这里吧，写下博客的第一篇文章难免有些激动。最后附上纪伯伦的短诗一篇，它为我曾经中最黑暗的那段日子点亮明灯。</p>
<h4 id="我的心曾悲伤七次"><a href="#我的心曾悲伤七次" class="headerlink" title="我的心曾悲伤七次"></a><strong>我的心曾悲伤七次</strong></h4><p><strong>第一次，当它本可进取时，却故作谦卑；</strong></p>
<p><strong>第二次，当它在空虚时，用爱欲来填充；</strong></p>
<p><strong>第三次，在困难和容易之间，它选择了容易；</strong></p>
<p><strong>第四次，它犯了错，却借由别人也会犯错来宽慰自己；</strong></p>
<p><strong>第五次，它自由软弱，却把它认为是生命的坚韧；</strong></p>
<p><strong>第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；</strong></p>
<p><strong>第七次，它侧身与生活的污泥中，虽不甘心，却又畏首畏尾。</strong></p>
<p>共勉！</p>
<p>（我的联系方式：<a href="mailto:&#84;&#x65;&#52;&#x4d;&#73;&#x56;&#97;&#x6c;&#x40;&#111;&#117;&#116;&#108;&#x6f;&#111;&#107;&#46;&#x63;&#111;&#x6d;">&#84;&#x65;&#52;&#x4d;&#73;&#x56;&#97;&#x6c;&#x40;&#111;&#117;&#116;&#108;&#x6f;&#111;&#107;&#46;&#x63;&#111;&#x6d;</a>）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/17/2023.3.17[%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2]/" data-id="clfl8f6in0000fou3bgtc7yhz" data-title="开始" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/23/2023.3.23%5BTuring%20Complete%E6%94%BB%E7%95%A5%5D/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/03/23/2023.3.23%5BSTM32%E7%A1%AC%E4%BB%B6%5D/">STM32F103ZE部分硬件配置指南</a>
          </li>
        
          <li>
            <a href="/2023/03/17/2023.3.17%5B%E6%B1%87%E7%BC%96%5D/">基础汇编分享</a>
          </li>
        
          <li>
            <a href="/2023/03/17/2023.3.17%5B%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%5D/">开始</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Te4MIVal<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>